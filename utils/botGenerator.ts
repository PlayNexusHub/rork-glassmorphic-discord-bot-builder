import { Capability } from '@/types/bot';

interface BotConfig {
  botName: string;
  botDescription: string;
  prefix: string;
  selectedCapabilities: string[];
  features: {
    slashCommands: boolean;
    prefixCommands: boolean;
    autoModeration: boolean;
    logging: boolean;
  };
}

interface GeneratedFile {
  name: string;
  content: string;
  size: string;
  type: string;
}

export function generateBotFiles(
  config: BotConfig,
  capabilities: Capability[]
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  const selectedCaps = capabilities.filter((cap) =>
    config.selectedCapabilities.includes(cap.id)
  );

  files.push(generateMainFile(config, selectedCaps));
  files.push(generateConfigFile(config));
  files.push(generateRequirementsFile(selectedCaps));
  files.push(generateReadmeFile(config, selectedCaps));
  files.push(generateEnvFile(config));
  files.push(generateGitignoreFile());

  selectedCaps.forEach((cap) => {
    cap.files.forEach((file) => {
      files.push(generateCapabilityFile(cap, file.target, config));
    });
  });

  return files;
}

function generateMainFile(config: BotConfig, capabilities: Capability[]): GeneratedFile {
  const content = `#!/usr/bin/env python3
"""
${config.botName}
${config.botDescription}

Generated by Discord Bot Builder
"""

import discord
from discord.ext import commands
import asyncio
import logging
from config import Config

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ${config.botName.replace(/\s+/g, '')}Bot(commands.Bot):
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        intents.members = True
        intents.guilds = True
        
        super().__init__(
            command_prefix="${config.prefix}",
            intents=intents,
            description="${config.botDescription}"
        )
        
    async def setup_hook(self):
        """Load all cogs and sync commands"""
        logger.info("Loading cogs...")
        
        ${capabilities.map((cap) => `# ${cap.title}\n        # await self.load_extension('cogs.${cap.id.replace('.', '_')}')`).join('\n        ')}
        
        ${config.features.slashCommands ? 'logger.info("Syncing slash commands...")\n        await self.tree.sync()' : ''}
        
    async def on_ready(self):
        logger.info(f'Logged in as {self.user} (ID: {self.user.id})')
        logger.info(f'Connected to {len(self.guilds)} guilds')
        logger.info('------')
        
    async def on_command_error(self, ctx, error):
        """Global error handler"""
        if isinstance(error, commands.CommandNotFound):
            return
        elif isinstance(error, commands.MissingPermissions):
            await ctx.send("❌ You don't have permission to use this command.")
        elif isinstance(error, commands.BotMissingPermissions):
            await ctx.send("❌ I don't have the required permissions.")
        elif isinstance(error, commands.CommandOnCooldown):
            await ctx.send(f"⏰ This command is on cooldown. Try again in {error.retry_after:.2f}s")
        else:
            logger.error(f'Error in command {ctx.command}: {error}', exc_info=error)
            await ctx.send("❌ An error occurred while executing the command.")

async def main():
    config = Config()
    bot = ${config.botName.replace(/\s+/g, '')}Bot()
    
    try:
        await bot.start(config.token)
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        await bot.close()

if __name__ == "__main__":
    asyncio.run(main())
`;

  return {
    name: 'main.py',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

function generateConfigFile(config: BotConfig): GeneratedFile {
  const content = `"""
Configuration file for ${config.botName}
"""

import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class Config:
    """Bot configuration"""
    
    # Bot Token (REQUIRED)
    token: str = os.getenv("DISCORD_TOKEN", "")
    
    # Bot Settings
    prefix: str = "${config.prefix}"
    bot_name: str = "${config.botName}"
    bot_description: str = "${config.botDescription}"
    
    # Features
    slash_commands: bool = ${config.features.slashCommands ? 'True' : 'False'}
    prefix_commands: bool = ${config.features.prefixCommands ? 'True' : 'False'}
    auto_moderation: bool = ${config.features.autoModeration ? 'True' : 'False'}
    logging_enabled: bool = ${config.features.logging ? 'True' : 'False'}
    
    # Database
    database_url: str = os.getenv("DATABASE_URL", "sqlite:///bot.db")
    
    # Redis (Optional)
    redis_url: Optional[str] = os.getenv("REDIS_URL", None)
    
    # API Keys (Optional)
    openai_api_key: Optional[str] = os.getenv("OPENAI_API_KEY", None)
    youtube_api_key: Optional[str] = os.getenv("YOUTUBE_API_KEY", None)
    spotify_client_id: Optional[str] = os.getenv("SPOTIFY_CLIENT_ID", None)
    spotify_client_secret: Optional[str] = os.getenv("SPOTIFY_CLIENT_SECRET", None)
    
    def __post_init__(self):
        if not self.token:
            raise ValueError("DISCORD_TOKEN environment variable is required!")
`;

  return {
    name: 'config.py',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

function generateRequirementsFile(capabilities: Capability[]): GeneratedFile {
  const requirements = new Set([
    'discord.py>=2.3.0',
    'python-dotenv>=1.0.0',
    'aiohttp>=3.9.0',
  ]);

  const capabilityDeps: Record<string, string[]> = {
    database: ['sqlalchemy>=2.0.0', 'aiosqlite>=0.19.0'],
    cache: ['redis>=5.0.0'],
    music: ['yt-dlp>=2023.0.0', 'PyNaCl>=1.5.0'],
    ai: ['openai>=1.0.0'],
    images: ['Pillow>=10.0.0'],
    ocr: ['pytesseract>=0.3.10'],
    tts: ['gTTS>=2.4.0'],
    crypto: ['requests>=2.31.0'],
  };

  capabilities.forEach((cap) => {
    cap.tags.forEach((tag) => {
      if (capabilityDeps[tag]) {
        capabilityDeps[tag].forEach((dep) => requirements.add(dep));
      }
    });
  });

  const content = Array.from(requirements).sort().join('\n') + '\n';

  return {
    name: 'requirements.txt',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateReadmeFile(config: BotConfig, capabilities: Capability[]): GeneratedFile {
  const content = `# ${config.botName}

${config.botDescription}

## Features

This bot includes the following capabilities:

${capabilities.map((cap) => `- **${cap.title}**: ${cap.description}`).join('\n')}

## Setup

1. **Install Dependencies**
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

2. **Configure Environment**
   
   Create a \`.env\` file with your Discord bot token:
   \`\`\`
   DISCORD_TOKEN=your_token_here
   \`\`\`

3. **Run the Bot**
   \`\`\`bash
   python main.py
   \`\`\`

## Configuration

Edit \`config.py\` to customize bot settings:

- **Prefix**: \`${config.prefix}\`
- **Slash Commands**: ${config.features.slashCommands ? 'Enabled' : 'Disabled'}
- **Prefix Commands**: ${config.features.prefixCommands ? 'Enabled' : 'Disabled'}
- **Auto Moderation**: ${config.features.autoModeration ? 'Enabled' : 'Disabled'}
- **Logging**: ${config.features.logging ? 'Enabled' : 'Disabled'}

## Commands

${config.features.slashCommands ? '### Slash Commands\n\nUse \`/\` to see all available slash commands.\n\n' : ''}${config.features.prefixCommands ? `### Prefix Commands\n\nUse \`${config.prefix}help\` to see all available commands.\n\n` : ''}

## Support

For issues or questions, please refer to the Discord.py documentation:
https://discordpy.readthedocs.io/

## License

This bot was generated by Discord Bot Builder.
`;

  return {
    name: 'README.md',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Markdown',
  };
}

function generateEnvFile(config: BotConfig): GeneratedFile {
  const content = `# Discord Bot Configuration
DISCORD_TOKEN=your_discord_bot_token_here

# Database (Optional)
# DATABASE_URL=sqlite:///bot.db

# Redis (Optional)
# REDIS_URL=redis://localhost:6379

# API Keys (Optional)
# OPENAI_API_KEY=your_openai_key
# YOUTUBE_API_KEY=your_youtube_key
# SPOTIFY_CLIENT_ID=your_spotify_id
# SPOTIFY_CLIENT_SECRET=your_spotify_secret
`;

  return {
    name: '.env.example',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateGitignoreFile(): GeneratedFile {
  const content = `# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
env/

# Environment Variables
.env
.env.local

# Database
*.db
*.sqlite
*.sqlite3

# Logs
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
`;

  return {
    name: '.gitignore',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateCapabilityFile(
  capability: Capability,
  targetPath: string,
  config: BotConfig
): GeneratedFile {
  const className = capability.title.replace(/\s+/g, '');
  
  const content = `"""
${capability.title}
${capability.description}

Risk Level: ${capability.riskLevel}
Complexity: ${capability.complexity}
"""

import discord
from discord.ext import commands
from discord import app_commands
import logging

logger = logging.getLogger(__name__)

class ${className}(commands.Cog):
    """${capability.description}"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        logger.info(f"Loaded {self.__class__.__name__}")
    
    ${config.features.slashCommands ? `@app_commands.command(name="${capability.id.split('.')[1]}", description="${capability.description}")
    async def ${capability.id.split('.')[1]}_slash(self, interaction: discord.Interaction):
        """${capability.description}"""
        await interaction.response.send_message(
            f"✨ {capability.title} is working!",
            ephemeral=True
        )
    ` : ''}
    
    ${config.features.prefixCommands ? `@commands.command(name="${capability.id.split('.')[1]}")
    async def ${capability.id.split('.')[1]}_prefix(self, ctx: commands.Context):
        """${capability.description}"""
        await ctx.send(f"✨ {capability.title} is working!")
    ` : ''}

async def setup(bot: commands.Bot):
    await bot.add_cog(${className}(bot))
`;

  return {
    name: targetPath,
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

export function downloadBotFiles(files: GeneratedFile[], botName: string) {
  console.log('Downloading bot files:', files.length);
  console.log('Bot name:', botName);
  
  files.forEach((file) => {
    console.log(`- ${file.name} (${file.size})`);
  });
}
