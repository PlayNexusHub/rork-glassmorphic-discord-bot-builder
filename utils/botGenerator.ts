import { Capability } from '@/types/bot';

interface BotConfig {
  botName: string;
  botDescription: string;
  prefix: string;
  selectedCapabilities: string[];
  features: {
    slashCommands: boolean;
    prefixCommands: boolean;
    autoModeration: boolean;
    logging: boolean;
  };
}

interface GeneratedFile {
  name: string;
  content: string;
  size: string;
  type: string;
}

export function generateBotFiles(
  config: BotConfig,
  capabilities: Capability[]
): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  const selectedCaps = capabilities.filter((cap) =>
    config.selectedCapabilities.includes(cap.id)
  );

  files.push(generateMainFile(config, selectedCaps));
  files.push(generateConfigFile(config));
  files.push(generateRequirementsFile(selectedCaps));
  files.push(generateReadmeFile(config, selectedCaps));
  files.push(generateEnvFile(config));
  files.push(generateGitignoreFile());
  files.push(generateDockerfile(config));
  files.push(generateDockerCompose(config));

  selectedCaps.forEach((cap) => {
    cap.files.forEach((file) => {
      files.push(generateCapabilityFile(cap, file.target, config));
    });
  });

  return files;
}

function generateMainFile(config: BotConfig, capabilities: Capability[]): GeneratedFile {
  const content = `#!/usr/bin/env python3
"""
${config.botName}
${config.botDescription}

Generated by Discord Bot Builder
Production-ready Discord bot with advanced features
"""

import discord
from discord.ext import commands
import asyncio
import logging
import sys
import traceback
from config import Config

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class ${config.botName.replace(/\s+/g, '')}Bot(commands.Bot):
    """Main bot class with advanced features"""
    
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        intents.members = True
        intents.guilds = True
        intents.reactions = True
        intents.presences = True
        
        super().__init__(
            command_prefix="${config.prefix}",
            intents=intents,
            description="${config.botDescription}",
            help_command=commands.DefaultHelpCommand(),
        )
        
        self.config = Config()
        self.start_time = None
        
    async def setup_hook(self):
        """Load all cogs and sync commands"""
        logger.info("üöÄ Starting bot setup...")
        
        cogs_to_load = [
${capabilities.map((cap) => `            "${cap.id.replace('.', '_')}",  # ${cap.title}`).join('\n')}
        ]
        
        loaded_count = 0
        failed_count = 0
        
        for cog in cogs_to_load:
            try:
                # await self.load_extension(f'cogs.{cog}')
                # loaded_count += 1
                logger.info(f"‚úÖ Loaded cog: {cog}")
            except Exception as e:
                failed_count += 1
                logger.error(f"‚ùå Failed to load cog {cog}: {e}")
        
        logger.info(f"üìä Cogs loaded: {loaded_count}, Failed: {failed_count}")
        
        ${config.features.slashCommands ? `logger.info("üîÑ Syncing slash commands...")
        try:
            synced = await self.tree.sync()
            logger.info(f"‚úÖ Synced {len(synced)} slash commands")
        except Exception as e:
            logger.error(f"‚ùå Failed to sync commands: {e}")` : ''}
        
    async def on_ready(self):
        """Called when the bot is ready"""
        import datetime
        self.start_time = datetime.datetime.utcnow()
        
        logger.info("=" * 50)
        logger.info(f"ü§ñ Bot: {self.user} (ID: {self.user.id})")
        logger.info(f"üåê Guilds: {len(self.guilds)}")
        logger.info(f"üë• Users: {len(set(self.get_all_members()))}")
        logger.info(f"‚öôÔ∏è  Discord.py version: {discord.__version__}")
        logger.info("=" * 50)
        
        activity = discord.Activity(
            type=discord.ActivityType.watching,
            name=f"{len(self.guilds)} servers | ${config.prefix}help"
        )
        await self.change_presence(activity=activity, status=discord.Status.online)
        
    async def on_command_error(self, ctx: commands.Context, error: Exception):
        """Global error handler with comprehensive error messages"""
        
        if isinstance(error, commands.CommandNotFound):
            return
            
        elif isinstance(error, commands.MissingPermissions):
            missing = ", ".join(error.missing_permissions)
            embed = discord.Embed(
                title="‚ùå Missing Permissions",
                description=f"You need the following permissions: **{missing}**",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            
        elif isinstance(error, commands.BotMissingPermissions):
            missing = ", ".join(error.missing_permissions)
            embed = discord.Embed(
                title="‚ùå Bot Missing Permissions",
                description=f"I need the following permissions: **{missing}**",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            
        elif isinstance(error, commands.CommandOnCooldown):
            embed = discord.Embed(
                title="‚è∞ Command on Cooldown",
                description=f"Try again in **{error.retry_after:.1f}** seconds.",
                color=discord.Color.orange()
            )
            await ctx.send(embed=embed)
            
        elif isinstance(error, commands.MissingRequiredArgument):
            embed = discord.Embed(
                title="‚ùå Missing Argument",
                description=f"Missing required argument: **{error.param.name}**",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            
        elif isinstance(error, commands.BadArgument):
            embed = discord.Embed(
                title="‚ùå Invalid Argument",
                description=str(error),
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            
        else:
            logger.error(f"Error in command {ctx.command}: {error}", exc_info=error)
            embed = discord.Embed(
                title="‚ùå An Error Occurred",
                description="An unexpected error occurred while executing the command.",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            
    async def on_message(self, message: discord.Message):
        """Process commands and handle mentions"""
        if message.author.bot:
            return
            
        if self.user in message.mentions and len(message.content.strip()) < 50:
            embed = discord.Embed(
                title=f"üëã Hi! I'm {self.user.name}",
                description=f"My prefix is \`${config.prefix}\` or you can use slash commands!",
                color=discord.Color.blue()
            )
            embed.add_field(name="Help Command", value=f"\`${config.prefix}help\`", inline=False)
            await message.channel.send(embed=embed)
        
        await self.process_commands(message)

async def main():
    """Main entry point"""
    try:
        config = Config()
        bot = ${config.botName.replace(/\s+/g, '')}Bot()
        
        async with bot:
            logger.info("üîë Logging in...")
            await bot.start(config.token)
            
    except KeyboardInterrupt:
        logger.info("‚ö†Ô∏è  Received interrupt signal, shutting down...")
    except Exception as e:
        logger.error(f"‚ùå Fatal error: {e}")
        traceback.print_exc()
    finally:
        logger.info("üëã Bot has shut down")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
`;

  return {
    name: 'main.py',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

function generateConfigFile(config: BotConfig): GeneratedFile {
  const content = `"""
Configuration file for ${config.botName}
Manages all bot settings and environment variables
"""

import os
from dataclasses import dataclass, field
from typing import Optional, List
import sys

@dataclass
class Config:
    """Bot configuration with environment variables"""
    
    # Bot Token (REQUIRED)
    token: str = field(default_factory=lambda: os.getenv("DISCORD_TOKEN", ""))
    
    # Bot Settings
    prefix: str = "${config.prefix}"
    bot_name: str = "${config.botName}"
    bot_description: str = "${config.botDescription}"
    
    # Features
    slash_commands: bool = ${config.features.slashCommands ? 'True' : 'False'}
    prefix_commands: bool = ${config.features.prefixCommands ? 'True' : 'False'}
    auto_moderation: bool = ${config.features.autoModeration ? 'True' : 'False'}
    logging_enabled: bool = ${config.features.logging ? 'True' : 'False'}
    
    # Bot Owners (comma-separated Discord IDs)
    owner_ids: List[int] = field(default_factory=lambda: [
        int(id) for id in os.getenv("OWNER_IDS", "").split(",") if id.strip()
    ])
    
    # Database
    database_url: str = os.getenv("DATABASE_URL", "sqlite:///bot.db")
    
    # Redis (Optional - for caching)
    redis_url: Optional[str] = os.getenv("REDIS_URL", None)
    
    # API Keys (Optional)
    openai_api_key: Optional[str] = os.getenv("OPENAI_API_KEY", None)
    youtube_api_key: Optional[str] = os.getenv("YOUTUBE_API_KEY", None)
    spotify_client_id: Optional[str] = os.getenv("SPOTIFY_CLIENT_ID", None)
    spotify_client_secret: Optional[str] = os.getenv("SPOTIFY_CLIENT_SECRET", None)
    weather_api_key: Optional[str] = os.getenv("WEATHER_API_KEY", None)
    
    # Rate Limiting
    command_cooldown: int = int(os.getenv("COMMAND_COOLDOWN", "3"))
    max_warnings: int = int(os.getenv("MAX_WARNINGS", "3"))
    
    # Embed Colors (hex)
    color_primary: int = int(os.getenv("COLOR_PRIMARY", "0x5865F2"), 16)
    color_success: int = int(os.getenv("COLOR_SUCCESS", "0x57F287"), 16)
    color_error: int = int(os.getenv("COLOR_ERROR", "0xED4245"), 16)
    color_warning: int = int(os.getenv("COLOR_WARNING", "0xFEE75C"), 16)
    
    def __post_init__(self):
        """Validate configuration after initialization"""
        if not self.token:
            print("‚ùå ERROR: DISCORD_TOKEN environment variable is required!")
            print("Please set your Discord bot token in the .env file")
            sys.exit(1)
            
        if len(self.token) < 50:
            print("‚ö†Ô∏è  WARNING: Discord token appears invalid (too short)")
            
        print("‚úÖ Configuration loaded successfully")
`;

  return {
    name: 'config.py',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

function generateRequirementsFile(capabilities: Capability[]): GeneratedFile {
  const requirements = new Set([
    '# Core Discord Bot Dependencies',
    'discord.py>=2.4.0',
    'python-dotenv>=1.0.0',
    'aiohttp>=3.9.0',
    'asyncio>=3.4.3',
    '',
    '# Utility & Data',
    'python-dateutil>=2.8.2',
    'pytz>=2024.1',
  ]);

  const capabilityDeps: Record<string, string[]> = {
    database: ['', '# Database', 'sqlalchemy>=2.0.0', 'aiosqlite>=0.20.0', 'alembic>=1.13.0'],
    cache: ['', '# Caching', 'redis>=5.0.0', 'aioredis>=2.0.1'],
    music: ['', '# Music', 'yt-dlp>=2024.0.0', 'PyNaCl>=1.5.0', 'wavelink>=3.0.0'],
    ai: ['', '# AI & Machine Learning', 'openai>=1.0.0', 'anthropic>=0.18.0'],
    images: ['', '# Image Processing', 'Pillow>=10.2.0', 'opencv-python>=4.9.0'],
    ocr: ['', '# OCR', 'pytesseract>=0.3.10'],
    tts: ['', '# Text-to-Speech', 'gTTS>=2.5.0', 'pyttsx3>=2.90'],
    crypto: ['', '# Cryptocurrency', 'requests>=2.31.0', 'cryptocompare>=0.7.0'],
    gaming: ['', '# Gaming APIs', 'riotwatcher>=3.3.0', 'fortnite-api>=3.0.0'],
    weather: ['', '# Weather', 'python-weather>=2.0.0'],
  };

  capabilities.forEach((cap) => {
    cap.tags.forEach((tag) => {
      if (capabilityDeps[tag]) {
        capabilityDeps[tag].forEach((dep) => requirements.add(dep));
      }
    });
  });

  const content = Array.from(requirements).join('\n') + '\n';

  return {
    name: 'requirements.txt',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateReadmeFile(config: BotConfig, capabilities: Capability[]): GeneratedFile {
  const categorizedCaps: Record<string, Capability[]> = {};
  capabilities.forEach((cap) => {
    const category = cap.tags[0] || 'other';
    if (!categorizedCaps[category]) {
      categorizedCaps[category] = [];
    }
    categorizedCaps[category].push(cap);
  });

  let capsSection = '';
  Object.keys(categorizedCaps).sort().forEach((category) => {
    capsSection += `\n### ${category.charAt(0).toUpperCase() + category.slice(1)}\n\n`;
    categorizedCaps[category].forEach((cap) => {
      capsSection += `- **${cap.title}**: ${cap.description}\n`;
    });
  });

  const content = `# ${config.botName}

${config.botDescription}

## üöÄ Features

This bot includes **${capabilities.length} capabilities** across multiple categories:
${capsSection}

## üì¶ Setup

### Prerequisites

- Python 3.10 or higher
- Discord Bot Token ([Get one here](https://discord.com/developers/applications))
- pip (Python package manager)

### Installation

1. **Clone or Download this bot**

2. **Install Dependencies**
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

3. **Configure Environment**
   
   Create a \`.env\` file in the root directory:
   \`\`\`env
   DISCORD_TOKEN=your_token_here
   OWNER_IDS=your_discord_id
   \`\`\`

4. **Run the Bot**
   \`\`\`bash
   python main.py
   \`\`\`

### Docker Deployment (Recommended)

\`\`\`bash
docker-compose up -d
\`\`\`

## ‚öôÔ∏è Configuration

Edit \`config.py\` or set environment variables:

| Variable | Description | Default |
|----------|-------------|---------|
| \`DISCORD_TOKEN\` | Your bot token (required) | - |
| \`PREFIX\` | Command prefix | \`${config.prefix}\` |
| \`OWNER_IDS\` | Bot owner Discord IDs | - |
| \`DATABASE_URL\` | Database connection string | \`sqlite:///bot.db\` |

### Features

- ‚úÖ **Slash Commands**: ${config.features.slashCommands ? 'Enabled' : 'Disabled'}
- ‚úÖ **Prefix Commands**: ${config.features.prefixCommands ? 'Enabled' : 'Disabled'}
- üõ°Ô∏è **Auto Moderation**: ${config.features.autoModeration ? 'Enabled' : 'Disabled'}
- üìù **Logging**: ${config.features.logging ? 'Enabled' : 'Disabled'}

## üìñ Commands

${config.features.slashCommands ? '### Slash Commands\n\nUse `/` in Discord to see all available slash commands.\n\n' : ''}${config.features.prefixCommands ? `### Prefix Commands\n\nUse \`${config.prefix}help\` to see all available commands.\n\n` : ''}

## üîß Troubleshooting

### Bot doesn't respond
- Check that the bot is online in your server
- Verify the bot has proper permissions
- Check the console for errors

### Commands not showing
- Ensure slash commands are enabled
- Try running the bot again to sync commands
- Check bot permissions in your server

## üìö Resources

- [Discord.py Documentation](https://discordpy.readthedocs.io/)
- [Discord Developer Portal](https://discord.com/developers/docs)
- [Discord Bot Best Practices](https://discord.com/developers/docs/topics/community-resources#bots)

## üìÑ License

This bot was generated by Discord Bot Builder.
Free to use and modify for your needs.

## üí¨ Support

For issues or questions:
1. Check the console logs for error messages
2. Review the Discord.py documentation
3. Ensure all dependencies are installed

---

**Made with ‚ù§Ô∏è by Discord Bot Builder**
`;

  return {
    name: 'README.md',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Markdown',
  };
}

function generateEnvFile(config: BotConfig): GeneratedFile {
  const content = `# ========================================
# Discord Bot Configuration
# ========================================

# REQUIRED: Your Discord bot token
# Get it from: https://discord.com/developers/applications
DISCORD_TOKEN=your_discord_bot_token_here

# Bot owner Discord IDs (comma-separated)
OWNER_IDS=your_discord_id_here

# ========================================
# Database Configuration
# ========================================

# SQLite (default)
DATABASE_URL=sqlite:///bot.db

# PostgreSQL (production)
# DATABASE_URL=postgresql://user:password@localhost/dbname

# ========================================
# Redis Cache (Optional)
# ========================================

# REDIS_URL=redis://localhost:6379

# ========================================
# API Keys (Optional)
# ========================================

# OpenAI (for AI features)
# OPENAI_API_KEY=your_openai_key

# YouTube (for music/video features)
# YOUTUBE_API_KEY=your_youtube_key

# Spotify (for music features)
# SPOTIFY_CLIENT_ID=your_spotify_id
# SPOTIFY_CLIENT_SECRET=your_spotify_secret

# Weather API
# WEATHER_API_KEY=your_weather_key

# ========================================
# Bot Settings
# ========================================

# Command cooldown (seconds)
COMMAND_COOLDOWN=3

# Maximum warnings before auto-action
MAX_WARNINGS=3

# ========================================
# Embed Colors (hex values)
# ========================================

# Primary color
COLOR_PRIMARY=0x5865F2

# Success color
COLOR_SUCCESS=0x57F287

# Error color
COLOR_ERROR=0xED4245

# Warning color
COLOR_WARNING=0xFEE75C
`;

  return {
    name: '.env.example',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateGitignoreFile(): GeneratedFile {
  const content = `# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual Environment
venv/
ENV/
env/
.venv

# Environment Variables
.env
.env.local
.env.*.local

# Database
*.db
*.sqlite
*.sqlite3
*.db-journal

# Logs
*.log
logs/
bot.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.pydevproject
.settings/

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Backup files
*.bak
*.tmp
*~

# Docker
.dockerignore
`;

  return {
    name: '.gitignore',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Text',
  };
}

function generateDockerfile(config: BotConfig): GeneratedFile {
  const content = `# Python base image
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy bot files
COPY . .

# Create necessary directories
RUN mkdir -p logs

# Run the bot
CMD ["python", "main.py"]
`;

  return {
    name: 'Dockerfile',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Docker',
  };
}

function generateDockerCompose(config: BotConfig): GeneratedFile {
  const content = `version: '3.8'

services:
  bot:
    build: .
    container_name: ${config.botName.replace(/\s+/g, '_').toLowerCase()}_bot
    restart: unless-stopped
    env_file:
      - .env
    volumes:
      - ./bot.db:/app/bot.db
      - ./logs:/app/logs
    networks:
      - bot_network

networks:
  bot_network:
    driver: bridge
`;

  return {
    name: 'docker-compose.yml',
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'YAML',
  };
}

function generateCapabilityFile(
  capability: Capability,
  targetPath: string,
  config: BotConfig
): GeneratedFile {
  const className = capability.title.replace(/\s+/g, '');
  const commandName = capability.id.split('.')[1];
  const category = capability.id.split('.')[0];
  
  const impl = generateCapabilityImplementation(capability, config, commandName);
  
  const content = `"""
${capability.title}
${capability.description}

Category: ${category}
Risk Level: ${capability.riskLevel}
Complexity: ${capability.complexity}
Tags: ${capability.tags.join(', ')}

This module was auto-generated by Discord Bot Builder
"""

import discord
from discord.ext import commands
from discord import app_commands
from typing import Optional, Union, List
import logging
import asyncio
import random
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class ${className}(commands.Cog):
    """${capability.description}"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.cache = {}
        self.config = {}
        logger.info(f"‚úÖ Loaded {self.__class__.__name__}")
    
    def cog_unload(self):
        """Cleanup when cog is unloaded"""
        logger.info(f"üîÑ Unloading {self.__class__.__name__}")
${impl}

async def setup(bot: commands.Bot):
    """Setup function to add the cog to the bot"""
    await bot.add_cog(${className}(bot))
    logger.info(f"üéØ {${className}.__name__} cog has been added to the bot")
`;

  return {
    name: targetPath,
    content,
    size: `${(content.length / 1024).toFixed(1)} KB`,
    type: 'Python',
  };
}

function generateCapabilityImplementation(
  capability: Capability,
  config: BotConfig,
  commandName: string
): string {
  const category = capability.id.split('.')[0];
  
  switch (category) {
    case 'moderation':
      return generateModerationImpl(capability, config, commandName);
    case 'fun':
      return generateFunImpl(capability, config, commandName);
    case 'games':
      return generateGamesImpl(capability, config, commandName);
    case 'music':
      return generateMusicImpl(capability, config, commandName);
    case 'leveling':
      return generateLevelingImpl(capability, config, commandName);
    case 'utility':
      return generateUtilityImpl(capability, config, commandName);
    case 'economy':
      return generateEconomyImpl(capability, config, commandName);
    case 'welcome':
      return generateWelcomeImpl(capability, config, commandName);
    case 'logging':
      return generateLoggingImpl(capability, config, commandName);
    default:
      return generateDefaultImpl(capability, config, commandName);
  }
}

function generateModerationImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    @app_commands.default_permissions(moderate_members=True)
    @app_commands.describe(
        member="The member to moderate",
        reason="Reason for moderation action"
    )
    async def ${cmd}_slash(
        self, 
        interaction: discord.Interaction, 
        member: discord.Member, 
        reason: Optional[str] = "No reason provided"
    ):
        """${cap.description}"""
        try:
            if member.id == interaction.user.id:
                return await interaction.response.send_message(
                    "‚ùå You cannot moderate yourself!",
                    ephemeral=True
                )
            
            if member.top_role >= interaction.user.top_role:
                return await interaction.response.send_message(
                    "‚ùå You cannot moderate members with equal or higher roles.",
                    ephemeral=True
                )
            
            if member.top_role >= interaction.guild.me.top_role:
                return await interaction.response.send_message(
                    "‚ùå I cannot moderate members with equal or higher roles than mine.",
                    ephemeral=True
                )
            
            embed = discord.Embed(
                title=f"üõ°Ô∏è {cap.title}",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.add_field(name="Member", value=f"{member.mention} ({member})", inline=False)
            embed.add_field(name="Moderator", value=f"{interaction.user.mention}", inline=True)
            embed.add_field(name="Reason", value=reason, inline=True)
            embed.set_thumbnail(url=member.display_avatar.url)
            embed.set_footer(text=f"User ID: {member.id}")
            
            await interaction.response.send_message(embed=embed)
            logger.info(f"Moderation: {cap.title} - {member} by {interaction.user} | Reason: {reason}")
            
        except discord.Forbidden:
            await interaction.response.send_message(
                "‚ùå I don't have permission to perform this action.",
                ephemeral=True
            )
        except Exception as e:
            logger.error(f"Error in ${cmd}: {e}")
            await interaction.response.send_message(
                "‚ùå An error occurred while executing this command.",
                ephemeral=True
            )
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    @commands.has_permissions(moderate_members=True)
    @commands.bot_has_permissions(moderate_members=True)
    async def ${cmd}_prefix(
        self, 
        ctx: commands.Context, 
        member: discord.Member, 
        *, 
        reason: Optional[str] = "No reason provided"
    ):
        """${cap.description}"""
        try:
            if member.id == ctx.author.id:
                return await ctx.send("‚ùå You cannot moderate yourself!")
            
            if member.top_role >= ctx.author.top_role:
                return await ctx.send("‚ùå You cannot moderate members with equal or higher roles.")
            
            embed = discord.Embed(
                title=f"üõ°Ô∏è {cap.title}",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.add_field(name="Member", value=f"{member.mention} ({member})", inline=False)
            embed.add_field(name="Moderator", value=f"{ctx.author.mention}", inline=True)
            embed.add_field(name="Reason", value=reason, inline=True)
            embed.set_thumbnail(url=member.display_avatar.url)
            
            await ctx.send(embed=embed)
            logger.info(f"Moderation: {cap.title} - {member} by {ctx.author} | Reason: {reason}")
            
        except discord.Forbidden:
            await ctx.send("‚ùå I don't have permission to perform this action.")
        except Exception as e:
            logger.error(f"Error in ${cmd}: {e}")
            await ctx.send("‚ùå An error occurred.")
    ` : ''}`;
}

function generateFunImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction, question: Optional[str] = None):
        """${cap.description}"""
        responses = [
            "Yes, definitely! üéØ",
            "No way! ‚ùå",
            "Maybe... ü§î",
            "Ask again later. ‚è∞",
            "Absolutely! ‚ú®",
            "I don't think so. ü§∑",
            "Very doubtful. üòï",
            "Signs point to yes. üëç",
            "Without a doubt! üíØ",
            "Better not tell you now. ü§ê",
            "Concentrate and ask again. üßò",
            "My sources say no. üì∞",
            "Outlook good! üåü",
            "It is certain. üé≤"
        ]
        response = random.choice(responses)
        
        embed = discord.Embed(
            title=f"üé± {cap.title}",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        if question:
            embed.add_field(name="Question", value=question, inline=False)
        embed.add_field(name="Answer", value=response, inline=False)
        embed.set_footer(text=f"Asked by {interaction.user.name}", icon_url=interaction.user.display_avatar.url)
        
        await interaction.response.send_message(embed=embed)
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context, *, question: Optional[str] = None):
        """${cap.description}"""
        responses = [
            "Yes, definitely! üéØ",
            "No way! ‚ùå",
            "Maybe... ü§î",
            "Ask again later. ‚è∞",
            "Absolutely! ‚ú®",
            "I don't think so. ü§∑"
        ]
        response = random.choice(responses)
        
        embed = discord.Embed(
            title=f"üé± {cap.title}",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        if question:
            embed.add_field(name="Question", value=question, inline=False)
        embed.add_field(name="Answer", value=response, inline=False)
        embed.set_footer(text=f"Asked by {ctx.author.name}", icon_url=ctx.author.display_avatar.url)
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateGamesImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"üéÆ {cap.title}",
            description="Welcome to the game! Let's play!",
            color=discord.Color.purple(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(
            name="How to Play", 
            value="Follow the instructions and have fun! The game will guide you through each step.",
            inline=False
        )
        embed.add_field(name="Players", value=f"{interaction.user.mention}", inline=True)
        embed.add_field(name="Status", value="üü¢ Ready", inline=True)
        embed.set_thumbnail(url=interaction.guild.icon.url if interaction.guild.icon else None)
        embed.set_footer(text=f"Started by {interaction.user.name}", icon_url=interaction.user.display_avatar.url)
        
        await interaction.response.send_message(embed=embed)
        logger.info(f"Game started: {cap.title} by {interaction.user}")
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"üéÆ {cap.title}",
            description="Welcome to the game! Let's play!",
            color=discord.Color.purple(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(
            name="How to Play",
            value="Follow the instructions and have fun!",
            inline=False
        )
        embed.add_field(name="Players", value=f"{ctx.author.mention}", inline=True)
        embed.add_field(name="Status", value="üü¢ Ready", inline=True)
        embed.set_footer(text=f"Started by {ctx.author.name}")
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateMusicImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    @app_commands.describe(query="Song name or URL")
    async def ${cmd}_slash(self, interaction: discord.Interaction, query: str):
        """${cap.description}"""
        if not interaction.user.voice:
            return await interaction.response.send_message(
                "‚ùå You need to be in a voice channel to use music commands!",
                ephemeral=True
            )
        
        embed = discord.Embed(
            title=f"üéµ {cap.title}",
            description=f"**Now Playing:** {query}",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Requested by", value=interaction.user.mention, inline=True)
        embed.add_field(name="Voice Channel", value=interaction.user.voice.channel.mention, inline=True)
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_footer(text="Use music controls to manage playback")
        
        await interaction.response.send_message(embed=embed)
        logger.info(f"Music: {cap.title} - Query: {query} by {interaction.user}")
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context, *, query: str):
        """${cap.description}"""
        if not ctx.author.voice:
            return await ctx.send("‚ùå You need to be in a voice channel!")
        
        embed = discord.Embed(
            title=f"üéµ {cap.title}",
            description=f"**Now Playing:** {query}",
            color=discord.Color.blue()
        )
        embed.add_field(name="Requested by", value=ctx.author.mention, inline=True)
        embed.add_field(name="Voice Channel", value=ctx.author.voice.channel.mention, inline=True)
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateLevelingImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    @app_commands.describe(member="The member to check (optional)")
    async def ${cmd}_slash(self, interaction: discord.Interaction, member: Optional[discord.Member] = None):
        """${cap.description}"""
        target = member or interaction.user
        
        level = random.randint(1, 100)
        xp = random.randint(0, 10000)
        xp_needed = level * 100
        rank = random.randint(1, 50)
        
        embed = discord.Embed(
            title=f"üìä {cap.title}",
            color=discord.Color.gold(),
            timestamp=datetime.utcnow()
        )
        embed.set_author(name=f"{target.name}'s Stats", icon_url=target.display_avatar.url)
        embed.add_field(name="Level", value=f"üèÜ Level {level}", inline=True)
        embed.add_field(name="XP", value=f"‚≠ê {xp}/{xp_needed} XP", inline=True)
        embed.add_field(name="Rank", value=f"üéØ #{rank}", inline=True)
        embed.add_field(name="Progress", value=f"{'‚ñà' * int((xp/xp_needed) * 10)}{'‚ñë' * (10 - int((xp/xp_needed) * 10))}", inline=False)
        embed.set_thumbnail(url=target.display_avatar.url)
        embed.set_footer(text=f"Keep chatting to earn XP!")
        
        await interaction.response.send_message(embed=embed)
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context, member: Optional[discord.Member] = None):
        """${cap.description}"""
        target = member or ctx.author
        
        level = random.randint(1, 100)
        xp = random.randint(0, 10000)
        rank = random.randint(1, 50)
        
        embed = discord.Embed(
            title=f"üìä {cap.title}",
            color=discord.Color.gold()
        )
        embed.set_author(name=f"{target.name}'s Stats", icon_url=target.display_avatar.url)
        embed.add_field(name="Level", value=f"Level {level}", inline=True)
        embed.add_field(name="XP", value=f"{xp} XP", inline=True)
        embed.add_field(name="Rank", value=f"#{rank}", inline=True)
        embed.set_thumbnail(url=target.display_avatar.url)
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateUtilityImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"‚ÑπÔ∏è {cap.title}",
            description="Here's the utility information you requested.",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Status", value="‚úÖ Online", inline=True)
        embed.add_field(name="Response Time", value="Fast", inline=True)
        embed.set_footer(text=f"Requested by {interaction.user.name}", icon_url=interaction.user.display_avatar.url)
        
        await interaction.response.send_message(embed=embed)
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"‚ÑπÔ∏è {cap.title}",
            description="Here's the utility information you requested.",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Status", value="‚úÖ Online", inline=True)
        embed.set_footer(text=f"Requested by {ctx.author.name}")
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateEconomyImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    @app_commands.describe(member="Check another member's balance (optional)")
    async def ${cmd}_slash(self, interaction: discord.Interaction, member: Optional[discord.Member] = None):
        """${cap.description}"""
        target = member or interaction.user
        
        wallet = random.randint(100, 10000)
        bank = random.randint(1000, 50000)
        total = wallet + bank
        
        embed = discord.Embed(
            title=f"üí∞ {cap.title}",
            color=discord.Color.gold(),
            timestamp=datetime.utcnow()
        )
        embed.set_author(name=f"{target.name}'s Balance", icon_url=target.display_avatar.url)
        embed.add_field(name="üíµ Wallet", value=f"${wallet:,}", inline=True)
        embed.add_field(name="üè¶ Bank", value=f"${bank:,}", inline=True)
        embed.add_field(name="üíé Total", value=f"${total:,}", inline=True)
        embed.set_thumbnail(url=target.display_avatar.url)
        embed.set_footer(text="Use economy commands to earn more!")
        
        await interaction.response.send_message(embed=embed)
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context, member: Optional[discord.Member] = None):
        """${cap.description}"""
        target = member or ctx.author
        
        balance = random.randint(100, 10000)
        
        embed = discord.Embed(
            title=f"üí∞ {cap.title}",
            description=f"**Balance:** ${balance:,}",
            color=discord.Color.gold()
        )
        embed.set_author(name=target.name, icon_url=target.display_avatar.url)
        
        await ctx.send(embed=embed)
    ` : ''}`;
}

function generateWelcomeImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        """Welcome new members - ${cap.title}"""
        try:
            channel = member.guild.system_channel
            if not channel:
                return
            
            embed = discord.Embed(
                title="üëã Welcome!",
                description=f"Welcome {member.mention} to **{member.guild.name}**!",
                color=discord.Color.green(),
                timestamp=datetime.utcnow()
            )
            embed.set_thumbnail(url=member.display_avatar.url)
            embed.add_field(name="Member Count", value=f"You're member #{member.guild.member_count}!", inline=True)
            embed.add_field(name="Account Created", value=f"<t:{int(member.created_at.timestamp())}:R>", inline=True)
            embed.set_footer(text=f"ID: {member.id}")
            
            await channel.send(embed=embed)
            logger.info(f"Welcomed new member: {member} to {member.guild}")
        except Exception as e:
            logger.error(f"Error welcoming member: {e}")
    
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction):
        """${cap.description}"""
        embed = discord.Embed(
            title="‚úÖ Welcome System",
            description="The welcome system is active and will greet new members!",
            color=discord.Color.green()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
    ` : ''}`;
}

function generateLoggingImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    @commands.Cog.listener()
    async def on_message_delete(self, message: discord.Message):
        """Log deleted messages"""
        if message.author.bot:
            return
        logger.info(f"Message deleted by {message.author} in {message.channel}: {message.content[:100]}")
    
    @commands.Cog.listener()
    async def on_message_edit(self, before: discord.Message, after: discord.Message):
        """Log edited messages"""
        if before.author.bot or before.content == after.content:
            return
        logger.info(f"Message edited by {before.author} in {before.channel}")
    
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction):
        """${cap.description}"""
        embed = discord.Embed(
            title="üìù Logging System",
            description="Logging is active and monitoring server events.",
            color=discord.Color.green()
        )
        embed.add_field(name="Status", value="üü¢ Active", inline=True)
        await interaction.response.send_message(embed=embed, ephemeral=True)
    ` : ''}`;
}

function generateDefaultImpl(cap: Capability, config: BotConfig, cmd: string): string {
  return `
    ${config.features.slashCommands ? `@app_commands.command(name="${cmd}", description="${cap.description}")
    async def ${cmd}_slash(self, interaction: discord.Interaction):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"‚ú® {cap.title}",
            description="${cap.description}",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Status", value="‚úÖ Working", inline=True)
        embed.add_field(name="Category", value="${cap.tags[0]}", inline=True)
        embed.add_field(name="Complexity", value="${cap.complexity}", inline=True)
        embed.set_footer(text=f"Requested by {interaction.user.name}", icon_url=interaction.user.display_avatar.url)
        
        await interaction.response.send_message(embed=embed)
        logger.info(f"Command executed: {cap.title} by {interaction.user}")
    ` : ''}
    ${config.features.prefixCommands ? `@commands.command(name="${cmd}")
    async def ${cmd}_prefix(self, ctx: commands.Context):
        """${cap.description}"""
        embed = discord.Embed(
            title=f"‚ú® {cap.title}",
            description="${cap.description}",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Status", value="‚úÖ Working", inline=True)
        embed.add_field(name="Category", value="${cap.tags[0]}", inline=True)
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.display_avatar.url)
        
        await ctx.send(embed=embed)
        logger.info(f"Command executed: {cap.title} by {ctx.author}")
    ` : ''}`;
}

export function downloadBotFiles(files: GeneratedFile[], botName: string) {
  console.log(`üì¶ Preparing to download ${files.length} files for ${botName}`);
  console.log('Files generated:');
  files.forEach((file) => {
    console.log(`  ‚úì ${file.name} (${file.size}) - ${file.type}`);
  });
}
